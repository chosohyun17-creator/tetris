<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Tetris with Ranking</title>
    <style>
        body {
            font-family: 'Malgun Gothic', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            color: #ecf0f1;
        }

        .game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            border-radius: 10px;
            background-color: #34495e;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        #game-board {
            --cell-size: 25px;
            width: calc(var(--cell-size) * 10);
            height: calc(var(--cell-size) * 20);
            border: 5px solid #2980b9;
            background-color: #1c2833;
            display: grid;
            grid-template-columns: repeat(10, 1fr); 
            grid-template-rows: repeat(20, 1fr);
        }

        .block { box-sizing: border-box; border: 1px solid rgba(255,255,255,0.05); }
        .block.I { background-color: #00FFFF; }
        .block.O { background-color: #FFFF00; }
        .block.T { background-color: #800080; }
        .block.S { background-color: #00FF00; }
        .block.Z { background-color: #FF0000; }
        .block.J { background-color: #0000FF; }
        .block.L { background-color: #FF7F00; }

        .info-panel { width: 180px; }
        #next-block {
            width: 100px; height: 100px;
            display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr);
            border: 2px solid #5499c7; background-color: #1c2833; margin-bottom: 20px;
        }
        .next-cell { box-sizing: border-box; border: 1px solid rgba(255,255,255,0.05); }

        /* 모달 스타일 (이름 입력 및 랭킹) */
        .modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 15px;
            text-align: center; z-index: 100; min-width: 250px; border: 2px solid #2980b9;
        }
        .hidden { display: none; }
        input { padding: 10px; width: 80%; margin-bottom: 15px; border-radius: 5px; border: none; }
        button {
            padding: 10px 20px; background-color: #2ecc71; border: none;
            color: white; cursor: pointer; border-radius: 5px; margin: 5px;
        }
        button:hover { background-color: #27ae60; }
        .rank-list { text-align: left; margin: 15px 0; max-height: 200px; overflow-y: auto; }
        .rank-item { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #444; }
    </style>
</head>
<body>

    <div class="game-container">
        <div id="game-board"></div>

        <div class="info-panel">
            <h3>TETRIS</h3>
            <p>Player: <span id="display-name">-</span></p>
            <p>Score: <span id="score">0</span></p>
            <p>Next:</p>
            <div id="next-block"></div>
            <button id="rank-btn">Ranking</button>
            <div style="font-size: 12px; margin-top: 10px; color: #bdc3c7;">
                Arrows: Move/Rotate<br>Space: Hard Drop
            </div>
        </div>

        <div id="name-modal" class="modal">
            <h2>Enter Name</h2>
            <input type="text" id="player-name" placeholder="Name" maxlength="10">
            <br>
            <button id="start-btn">Game Start</button>
        </div>

        <div id="rank-modal" class="modal hidden">
            <h2>Top 10 Rankings</h2>
            <div id="rank-content" class="rank-list"></div>
            <button id="close-rank">Close</button>
        </div>

        <div id="game-over-modal" class="modal hidden">
            <h2 style="color: #e74c3c;">Game Over</h2>
            <p>Your Score: <span id="final-score">0</span></p>
            <button id="restart-btn">Try Again</button>
        </div>
    </div>

    <script>
        const ROWS = 20, COLS = 10;
        const gameBoard = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const nextBlockContainer = document.getElementById('next-block');
        
        let board = [], currentBlock = null, nextBlockType = null;
        let gameLoop, score = 0, gameRunning = false, playerName = "";

        const TETROMINOES = {
            'I': { shape: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], type: 'I' },
            'J': { shape: [[1,0,0], [1,1,1], [0,0,0]], type: 'J' },
            'L': { shape: [[0,0,1], [1,1,1], [0,0,0]], type: 'L' },
            'O': { shape: [[1,1], [1,1]], type: 'O' },
            'S': { shape: [[0,1,1], [1,1,0], [0,0,0]], type: 'S' },
            'T': { shape: [[0,1,0], [1,1,1], [0,0,0]], type: 'T' },
            'Z': { shape: [[1,1,0], [0,1,1], [0,0,0]], type: 'Z' }
        };
        const TETROMINO_KEYS = Object.keys(TETROMINOES);

        // --- 초기화 및 UI 제어 ---
        function initBoard() {
            board = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));
            gameBoard.innerHTML = '';
            for (let i = 0; i < ROWS * COLS; i++) {
                const cell = document.createElement('div');
                cell.classList.add('block');
                gameBoard.appendChild(cell);
            }
            nextBlockContainer.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.classList.add('next-cell');
                nextBlockContainer.appendChild(cell);
            }
        }

        function renderBoard() {
            const cells = gameBoard.querySelectorAll('.block');
            board.forEach((row, r) => {
                row.forEach((type, c) => {
                    const idx = r * COLS + c;
                    cells[idx].className = 'block' + (type ? ' ' + type : '');
                });
            });
            if (currentBlock) {
                currentBlock.shape.forEach((row, r) => {
                    row.forEach((val, c) => {
                        if (val) {
                            const br = currentBlock.y + r, bc = currentBlock.x + c;
                            if (br >= 0 && br < ROWS && bc >= 0 && bc < COLS) {
                                cells[br * COLS + bc].className = 'block ' + currentBlock.type;
                            }
                        }
                    });
                });
            }
            scoreElement.textContent = score;
        }

        function renderNextBlock() {
            const cells = nextBlockContainer.querySelectorAll('.next-cell');
            cells.forEach(c => c.className = 'next-cell');
            const data = TETROMINOES[nextBlockType];
            let ox = (nextBlockType === 'I') ? 0 : 1;
            let oy = (nextBlockType === 'I' || nextBlockType === 'O') ? 0 : 1;

            data.shape.forEach((row, r) => {
                row.forEach((val, c) => {
                    if (val) {
                        const idx = (r + oy) * 4 + (c + ox);
                        if(cells[idx]) cells[idx].classList.add(nextBlockType);
                    }
                });
            });
        }

        // --- 게임 로직 ---
        function checkCollision(shape, x, y) {
            return shape.some((row, r) => row.some((val, c) => {
                if (!val) return false;
                let bc = x + c, br = y + r;
                return bc < 0 || bc >= COLS || br >= ROWS || (br >= 0 && board[br][bc] !== 0);
            }));
        }

        function generateBlock() {
            const type = nextBlockType || TETROMINO_KEYS[Math.floor(Math.random() * 7)];
            nextBlockType = TETROMINO_KEYS[Math.floor(Math.random() * 7)];
            currentBlock = { shape: TETROMINOES[type].shape, type: type, x: 3, y: 0 };
            renderNextBlock();
            if (checkCollision(currentBlock.shape, currentBlock.x, currentBlock.y)) return false;
            return true;
        }

        function freezeBlock() {
            currentBlock.shape.forEach((row, r) => {
                row.forEach((val, c) => {
                    if (val && currentBlock.y + r >= 0) board[currentBlock.y + r][currentBlock.x + c] = currentBlock.type;
                });
            });
            clearLines();
        }

        function clearLines() {
            let lines = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(v => v !== 0)) {
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(0));
                    lines++; r++;
                }
            }
            score += [0, 100, 300, 500, 800][lines] || 0;
        }

        function rotate(shape) {
            return shape[0].map((_, i) => shape.map(row => row[i]).reverse());
        }

        function dropBlock() {
            if (!checkCollision(currentBlock.shape, currentBlock.x, currentBlock.y + 1)) {
                currentBlock.y++;
            } else {
                freezeBlock();
                if (!generateBlock()) gameOver();
            }
            renderBoard();
        }

        // --- 랭킹 시스템 ---
        function saveScore(name, score) {
            let ranks = JSON.parse(localStorage.getItem('tetrisRanks') || '[]');
            ranks.push({ name, score, date: new Date().toLocaleDateString() });
            ranks.sort((a, b) => b.score - a.score);
            localStorage.setItem('tetrisRanks', JSON.stringify(ranks.slice(0, 10)));
        }

        function showRanking() {
            const ranks = JSON.parse(localStorage.getItem('tetrisRanks') || '[]');
            const content = document.getElementById('rank-content');
            content.innerHTML = ranks.map((r, i) => `
                <div class="rank-item">
                    <span>${i+1}. ${r.name}</span>
                    <span>${r.score}</span>
                </div>
            `).join('') || "No records yet!";
            document.getElementById('rank-modal').classList.remove('hidden');
        }

        // --- 게임 관리 ---
        function startGame() {
            const inputName = document.getElementById('player-name').value.trim();
            if (!inputName) { alert("Please enter your name!"); return; }
            playerName = inputName;
            document.getElementById('display-name').textContent = playerName;
            document.getElementById('name-modal').classList.add('hidden');
            document.getElementById('game-over-modal').classList.add('hidden');
            
            score = 0;
            initBoard();
            generateBlock();
            gameRunning = true;
            gameLoop = setInterval(dropBlock, 800);
        }

        function gameOver() {
            clearInterval(gameLoop);
            gameRunning = false;
            saveScore(playerName, score);
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over-modal').classList.remove('hidden');
        }

        // --- 이벤트 리스너 ---
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', () => {
            document.getElementById('game-over-modal').classList.add('hidden');
            document.getElementById('name-modal').classList.remove('hidden');
        });
        document.getElementById('rank-btn').addEventListener('click', showRanking);
        document.getElementById('close-rank').addEventListener('click', () => {
            document.getElementById('rank-modal').classList.add('hidden');
        });

        document.addEventListener('keydown', e => {
            if (!gameRunning) return;
            if (e.key === 'ArrowLeft' && !checkCollision(currentBlock.shape, currentBlock.x - 1, currentBlock.y)) currentBlock.x--;
            if (e.key === 'ArrowRight' && !checkCollision(currentBlock.shape, currentBlock.x + 1, currentBlock.y)) currentBlock.x++;
            if (e.key === 'ArrowDown') dropBlock();
            if (e.key === 'ArrowUp') {
                const nextS = rotate(currentBlock.shape);
                if (!checkCollision(nextS, currentBlock.x, currentBlock.y)) currentBlock.shape = nextS;
            }
            if (e.key === ' ') {
                while (!checkCollision(currentBlock.shape, currentBlock.x, currentBlock.y + 1)) currentBlock.y++;
                dropBlock();
            }
            renderBoard();
        });

        initBoard();
    </script>
</body>
</html>
